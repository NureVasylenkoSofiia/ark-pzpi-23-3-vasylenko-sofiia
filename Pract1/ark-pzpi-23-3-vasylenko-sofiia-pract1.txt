Міністерство освіти та науки України


Харківський національний університет радіоелектроніки


Кафедра «Програмна інженерія»




ЗВІТ 
з практичної роботи №1
з дисципліни “Аналіз та рефакторинг коду”
на тему:  “Правила оформлення програмного коду. Чистий код, LINQ та async/await у бекенд-розробці мовою C#”








Виконала:
ст. гр. ПЗПІ-23-3                                                       Василенко С. О.                                                         
Перевірив:                                                  
ст. викладач  каф ПІ                                                Сокорчук Ігор Петрович




                                        






Харків 2025 .
1 ІСТОРІЯ ЗМІН


Таблиця 1.1 — Історія змін у звіті
№
	Дата
	Версія звіту
	Опис змін та виправлень
	1
	26.11.2025
	0.1
	Початок роботи над презентацією
	2
	28.11.2025
	0.2
	Редагування попередньої версії
	3
	30.11.2025
	0.3
	Сформовано фінальний звіт згідно з ДСТУ 3008:2015
	

 
________________


2 ЗАВДАННЯ


Презентація на тему: “Правила оформлення програмного коду. Чистий код, LINQ та async/await у бекенд-розробці мовою C#”.
________________


3 ОПИС ВИКОНАНОЇ РОБОТИ


У межах практичної роботи було досліджено правила оформлення програмного коду мовою C# з акцентом на сучасні технології, що широко застосовуються у бекенд-розробці: принципи чистого коду, використання LINQ та асинхронного програмування за допомогою async/await.
На основі рекомендацій Роберта Мартіна[1] та керівництва Framework Design Guidelines[2] було проаналізовано, як дотримання стилю і структурних принципів безпосередньо впливає на читабельність та підтримуваність коду. Особлива увага була приділена створенню зрозумілих конструкцій, мінімізації дублювання логіки, правильній організації послідовності операцій та підвищенню прозорості виконання.
Окремий акцент зроблено на роботі з LINQ, який є ключовим інструментом обробки колекцій у C#. Було продемонстровано, що занадто довгі та вкладені запити ускладнюють розуміння та налагодження коду. Показано приклади рефакторингу, у яких громіздкі LINQ-вирази були перетворені у зрозумілі та структуровані послідовності з проміжними змінними. Такий підхід суттєво покращує читабельність і знижує ризик помилок. 
У частині, що стосується async/await, було проаналізовано типові порушення асинхронної моделі: блокування потоків через .Result і .Wait(), змішування синхронного та асинхронного коду, недотримання єдиного async-ланцюжка. На практичних прикладах продемонстровано, як неправильна побудова асинхронних методів може призводити до втрати продуктивності й проблем масштабування у бекенд-системах.
________________


ВИСНОВКИ


У процесі практичної роботи було розглянуто ключові правила оформлення коду мовою C#, які мають критичне значення для сучасної бекенд-розробки. Було проаналізовано основні принципи чистого коду, що включають простоту, зрозумілість логіки, прозорість намірів та відсутність зайвої складності.
Дослідження показало, що правильне використання LINQ робить код більш декларативним, зручним для читання і менш схильним до помилок. Рефакторинг великих та нечітких запитів дозволяє створювати логічно послідовні та продуктивні структури обробки даних, що позитивно впливає на підтримку та масштабування системи.
Отримані результати показують, що поєднання принципів чистого коду, структурованого LINQ та коректної асинхронності дозволяє створювати високоякісні програмні рішення, які легко читати, модифікувати, тестувати та підтримувати. Дотримання цих правил є необхідною умовою ефективної командної розробки та успішного довготривалого розвитку програмного забезпечення.
________________
ВИКОРИСТАНІ ДЖЕРЕЛА


1. Мартін Р. С. Чистий код. Створення і рефакторинг за допомогою Agile. URL: https://uabook.com.ua/wp-content/uploads/2025/11/chystyy-kod.-stvorennia-i-refaktorynh-za-dopomohoiu-agile.pdf (дата звернення: 26.11.2025).
2. Naming Guidelines - Framework Design Guidelines. Microsoft Learn: Build skills that open doors in your career. URL: https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/naming-guidelines?utm (дата звернення: 26.11.2025). 
________________
ДОДАТОК А
Відеозапис
Відеозапис презентації практичної роботи: 
https://youtu.be/lCdjFVniEP4
00:00 - Вступ до практичної роботи №1, тема презентації
00:12 - План презентації
00:51 - C# у бекенді
01:29 - Поняття чистого коду
01:46 - Принципи чистого коду
02:05 - Що таке LINQ?
02:39 - Приклад поганого коду
04:00 - Приклад гарного коду
05:16 - Продуктивність LINQ
06:29 - Проміжні висновки (LINQ)
06:49 - Основний принцип async/await
07:52 - Приклад поганого коду
08:24 -  Приклад гарного коду
08:54 - Практичні поради для правильного async-коду
10:18 - Проміжні висновки (async/await)
10:44 - Загальні висновки
11:18 - Дякую за увагу!
________________


ДОДАТОК Б
Графічні матеріали
  

Рисунок Б.1 - Титульний слайд презентації


  

Рисунок Б.2 - План презентації
  

Рисунок Б.3 - C# у бекенді


  

Рисунок Б.4 - Поняття чистого коду
  

Рисунок Б.5 - Принципи чистого коду


  

Рисунок Б.6 - Що таке LINQ?


  

Рисунок Б.7 - Приклад поганого коду


  

Рисунок Б.8 - Приклад поганого коду
  

Рисунок Б.9 - Продуктивність LINQ


  

Рисунок Б.10 - Проміжні висновки (LINQ)




  

Рисунок Б.11 - Основний принцип async/await


  

Рисунок Б.12 - Приклад поганого коду




  

Рисунок Б.13 - Приклад гарного коду


  

Рисунок Б.14 - Практичні поради для правильного async-коду


  

Рисунок Б.15 - Проміжні висновки (LINQ)


  

Рисунок Б.16 - Загальні висновки 


  

Рисунок Б.17 - Дякую за увагу! 
________________
ДОДАТОК Б
Програмний код


В.1 Приклад поганого коду для LINQ
1  var result = orders.Where(x => x.Status == "Active")
2      .Where(x => x.Price > 100)
3      .Select(x => new { x.Id, x.Client, x.Price, x.Date })
4      .Where(x => x.Date > startDate)
5      .Where(x => clients.Any(c => c == x.Client))
6      .ToList();


В.2 Приклад гарного коду для LINQ
1  var activeOrders = orders
2      .Where(o => o.Status == "Active");


3  var expensiveOrders = activeOrders
4      .Where(o => o.Price > 100);


5  var russianClients = expensiveOrders
6      .Where(o => clients.Contains(o.Client));


7  var result = russianClients
8      .Where(o => o.Date > startDate)
9      .Select(o => new OrderDto(o))
10     .ToList();


В.3 Приклад поганого коду для async/await
1  public string GetUserName()
2  {
3      var user = userService.GetUserAsync(id).Result;
4      return user.Name;
5  }






В.4 Приклад гарного коду для async/await
1  public async Task<string> GetUserNameAsync()
2  {
3      var user = await userService
4          .GetUserAsync(id)
5          .ConfigureAwait(false);
6
7      return user.Name;
8  }


В.5 Приклад поганого коду 
1  public UserReport GetUserReport(int userId)
2  {
3      // Блокуємо потік: async-виклик + .Result
4      var orders = _orderService.GetOrdersAsync(userId).Result;
5
6      // Складний, важко читабельний LINQ
7      var filtered = orders
8          .Where(o => o.Status == "Completed")
9          .Where(o => o.Price > 100)
10         .Where(o => o.Date > DateTime.UtcNow.AddMonths(-1))
11         .Select(o => new
12         {
13             o.Id,
14             o.Price,
15             o.Date,
16             o.ProductName
17         })
18         .Where(o => _popularProducts.Any(p => p == o.ProductName))
19         .ToList();
20
21     // Блокуємо потік знову
22     var user = _userService.GetUserAsync(userId).Result;
23
24     return new UserReport
25     {
26         UserName = user.Name,
27         Orders = filtered
28     };
29 }




В.6 Приклад коду після рефакторингу
1  public async Task<UserReport> GetUserReportAsync(int userId)
2  {
3      var oneMonthAgo = DateTime.UtcNow.AddMonths(-1);
4
5      // Асинхронно отримуємо замовлення — без блокувань
6      var orders = await _orderService
7          .GetOrdersAsync(userId)
8          .ConfigureAwait(false);
9
10     // Структурований, читабельний LINQ-потік
11     var completedOrders = orders
12         .Where(o => o.Status == "Completed");
13
14     var recentOrders = completedOrders
15         .Where(o => o.Date > oneMonthAgo);
16
17     var expensiveOrders = recentOrders
18         .Where(o => o.Price > 100);
19
20     var popularOrders = expensiveOrders
21         .Where(o => _popularProducts.Contains(o.ProductName));
22
23     var orderDtos = popularOrders
24         .Select(o => new OrderDto(o))
25         .ToList();
26
27     // Асинхронно отримуємо користувача
28     var user = await _userService
29         .GetUserAsync(userId)
30         .ConfigureAwait(false);
31
32     return new UserReport
33     {
34         UserName = user.Name,
35         Orders = orderDtos
36     };
37 }